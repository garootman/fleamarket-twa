name: Check Webhook Health

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to check'
        required: true
        type: string
      run_full_test:
        description: 'Run full webhook test (requires test chat ID)'
        required: false
        default: false
        type: boolean
  schedule:
    # Run every hour for production monitoring
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to check'
        required: true
        default: 'production'
        type: choice
        options:
          - preview
          - production
      run_full_test:
        description: 'Run full webhook test (requires test chat ID)'
        required: false
        default: false
        type: boolean

jobs:
  check-webhook:
    name: Webhook Health Check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          ENV="${{ inputs.environment || github.event.inputs.environment || 'production' }}"
          echo "environment=$ENV" >> $GITHUB_OUTPUT

          # Set URLs and secrets based on environment
          if [ "$ENV" = "production" ]; then
            echo "bot_token_secret=TELEGRAM_BOT_TOKEN_PROD" >> $GITHUB_OUTPUT
            echo "worker_url=https://twa-cf-tpl-prod.${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.workers.dev" >> $GITHUB_OUTPUT
          else
            echo "bot_token_secret=TELEGRAM_BOT_TOKEN_PREVIEW" >> $GITHUB_OUTPUT
            echo "worker_url=https://twa-cf-tpl-preview.${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.workers.dev" >> $GITHUB_OUTPUT
          fi

      - name: Check Worker Health
        id: worker-health
        run: |
          WORKER_URL="${{ steps.env.outputs.worker_url }}"
          echo "Checking Worker health at: $WORKER_URL"

          # Check health endpoint
          HEALTH_RESPONSE=$(curl -s "$WORKER_URL/health" || echo '{"error": "unreachable"}')
          echo "Health response: $HEALTH_RESPONSE"

          STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status // "unknown"')
          echo "worker_status=$STATUS" >> $GITHUB_OUTPUT

          if [ "$STATUS" = "healthy" ]; then
            echo "‚úÖ Worker is healthy"
          elif [ "$STATUS" = "degraded" ]; then
            echo "‚ö†Ô∏è  Worker is degraded"
          else
            echo "‚ùå Worker is unhealthy or unreachable"
            echo "worker_healthy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "worker_healthy=true" >> $GITHUB_OUTPUT

      - name: Check Bot Status
        id: bot-status
        run: |
          BOT_TOKEN="${{ secrets[steps.env.outputs.bot_token_secret] }}"
          echo "Checking bot status..."

          # Get bot info
          BOT_INFO=$(curl -s "https://api.telegram.org/bot$BOT_TOKEN/getMe")
          echo "Bot info response:"
          echo "$BOT_INFO" | jq .

          if echo "$BOT_INFO" | jq -e '.ok' > /dev/null; then
            BOT_USERNAME=$(echo "$BOT_INFO" | jq -r '.result.username')
            echo "‚úÖ Bot is accessible: @$BOT_USERNAME"
            echo "bot_accessible=true" >> $GITHUB_OUTPUT
            echo "bot_username=$BOT_USERNAME" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Bot is not accessible"
            echo "bot_accessible=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check Webhook Configuration
        id: webhook-config
        run: |
          BOT_TOKEN="${{ secrets[steps.env.outputs.bot_token_secret] }}"
          echo "Checking webhook configuration..."

          WEBHOOK_INFO=$(curl -s "https://api.telegram.org/bot$BOT_TOKEN/getWebhookInfo")
          echo "Webhook info:"
          echo "$WEBHOOK_INFO" | jq .

          # Extract webhook details
          WEBHOOK_URL=$(echo "$WEBHOOK_INFO" | jq -r '.result.url // ""')
          PENDING_UPDATES=$(echo "$WEBHOOK_INFO" | jq -r '.result.pending_update_count // 0')
          LAST_ERROR_DATE=$(echo "$WEBHOOK_INFO" | jq -r '.result.last_error_date // ""')
          LAST_ERROR_MSG=$(echo "$WEBHOOK_INFO" | jq -r '.result.last_error_message // ""')
          MAX_CONNECTIONS=$(echo "$WEBHOOK_INFO" | jq -r '.result.max_connections // 0')

          echo "webhook_url=$WEBHOOK_URL" >> $GITHUB_OUTPUT
          echo "pending_updates=$PENDING_UPDATES" >> $GITHUB_OUTPUT
          echo "last_error_date=$LAST_ERROR_DATE" >> $GITHUB_OUTPUT

          # Verify webhook URL matches expected
          EXPECTED_URL="${{ steps.env.outputs.worker_url }}/webhook"
          if [ "$WEBHOOK_URL" = "$EXPECTED_URL" ]; then
            echo "‚úÖ Webhook URL is correctly configured"
            echo "webhook_url_correct=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Webhook URL mismatch!"
            echo "Expected: $EXPECTED_URL"
            echo "Actual: $WEBHOOK_URL"
            echo "webhook_url_correct=false" >> $GITHUB_OUTPUT
          fi

          # Check for errors
          if [ "$LAST_ERROR_MSG" != "" ]; then
            echo "‚ö†Ô∏è  Last webhook error: $LAST_ERROR_MSG"
            if [ "$LAST_ERROR_DATE" != "" ]; then
              echo "Error date: $(date -d @$LAST_ERROR_DATE 2>/dev/null || echo $LAST_ERROR_DATE)"
            fi
          fi

          # Check pending updates
          if [ "$PENDING_UPDATES" -gt "0" ]; then
            echo "‚ö†Ô∏è  Pending updates: $PENDING_UPDATES"
          fi

      - name: Test Webhook Endpoint
        run: |
          WEBHOOK_URL="${{ steps.webhook-config.outputs.webhook_url }}"
          echo "Testing webhook endpoint accessibility..."

          # Test if webhook endpoint is reachable (should return 400 for GET request)
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$WEBHOOK_URL")

          if [ "$RESPONSE" = "404" ]; then
            echo "‚ùå Webhook endpoint not found (404)"
            exit 1
          elif [ "$RESPONSE" = "405" ] || [ "$RESPONSE" = "400" ]; then
            echo "‚úÖ Webhook endpoint is accessible (returned $RESPONSE as expected for GET)"
          else
            echo "‚ö†Ô∏è  Webhook endpoint returned unexpected status: $RESPONSE"
          fi

      - name: Full Webhook Test (Optional)
        if: ${{ (inputs.run_full_test || github.event.inputs.run_full_test) == 'true' && secrets.TEST_CHAT_ID }}
        continue-on-error: true
        run: |
          BOT_TOKEN="${{ secrets[steps.env.outputs.bot_token_secret] }}"
          TEST_CHAT_ID="${{ secrets.TEST_CHAT_ID }}"

          echo "Running full webhook test with test chat..."

          # Send a test message to trigger webhook
          TEST_MESSAGE="üß™ Webhook health check - $(date)"
          SEND_RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -H "Content-Type: application/json" \
            -d "{
              \"chat_id\": \"$TEST_CHAT_ID\",
              \"text\": \"$TEST_MESSAGE\"
            }")

          echo "Send message response:"
          echo "$SEND_RESPONSE" | jq .

          if echo "$SEND_RESPONSE" | jq -e '.ok' > /dev/null; then
            echo "‚úÖ Test message sent successfully"
          else
            echo "‚ùå Failed to send test message"
          fi

      - name: Generate Health Report
        run: |
          echo "# üè• Webhook Health Report"
          echo ""
          echo "**Environment:** ${{ steps.env.outputs.environment }}"
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "## Status Summary"
          echo ""

          if [ "${{ steps.worker-health.outputs.worker_healthy }}" = "true" ]; then
            echo "‚úÖ **Worker Health:** ${{ steps.worker-health.outputs.worker_status }}"
          else
            echo "‚ùå **Worker Health:** Unhealthy"
          fi

          if [ "${{ steps.bot-status.outputs.bot_accessible }}" = "true" ]; then
            echo "‚úÖ **Bot Status:** Accessible (@${{ steps.bot-status.outputs.bot_username }})"
          else
            echo "‚ùå **Bot Status:** Not accessible"
          fi

          if [ "${{ steps.webhook-config.outputs.webhook_url_correct }}" = "true" ]; then
            echo "‚úÖ **Webhook URL:** Correctly configured"
          else
            echo "‚ùå **Webhook URL:** Misconfigured"
          fi

          echo ""
          echo "## Details"
          echo ""
          echo "- **Worker URL:** ${{ steps.env.outputs.worker_url }}"
          echo "- **Webhook URL:** ${{ steps.webhook-config.outputs.webhook_url }}"
          echo "- **Pending Updates:** ${{ steps.webhook-config.outputs.pending_updates }}"

          if [ "${{ steps.webhook-config.outputs.last_error_date }}" != "" ]; then
            echo "- **Last Error:** ${{ steps.webhook-config.outputs.last_error_date }}"
          fi

  health-notification:
    name: Health Check Notification
    runs-on: ubuntu-latest
    needs: check-webhook
    if: always()
    steps:
      - name: Health Check Status
        run: |
          if [ "${{ needs.check-webhook.result }}" = "success" ]; then
            echo "‚úÖ Webhook health check passed"
          else
            echo "‚ùå Webhook health check failed"
            echo "Check the logs above for details"
            exit 1
          fi